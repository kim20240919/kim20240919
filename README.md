## top, ps, jobs, kill 명령어 소개.

 # top 명령어는 리눅스에서 시스템의 실시간 성능 정보를 모니터링하는데 사용되는 명령어입니다.

 다음과같은 정보를 확인할수있습니다.
 

- 시스템 정보 헤더

현재 시간, 시스템의 가동 시간 (uptime), 로그인한 사용자 수, 평균 부하 (load average)

- 작업 및 CPU 상태
  
전체 작업 수 (tasks), 실행 중인 작업 (running), 대기 중인 작업 (sleeping), 중지된 작업 (stopped), 좀비 작업 (zombie)

- CPU 사용량
  
사용자 모드에서의 CPU 사용량 (us), 시스템 모드에서의 CPU 사용량 (sy), 낮은 우선순위의 사용자 모드에서의 CPU 사용량 (ni), 대기 중인 CPU 사용량 (wa), 

하드웨어 인터럽트에서의 CPU 사용량 (hi), 소프트웨어 인터럽트에서의 CPU 사용량 (si), 가상화 하이퍼바이저에서 사용된 CPU 시간 (st)

- 메모리 사용량
  
총 메모리 (total), 사용 중인 메모리 (used), 사용 가능한 메모리 (free), 버퍼된 메모리 (buffers), 캐시된 메모리 (cached)

- 프로세스 목록


top 명령어의 주요 옵션으로는


-d: 업데이트 간격을 설정합니다. 기본값은 3초입니다.


-n: 지정한 횟수만큼 업데이트를 수행하고 종료합니다.


-P: CPU 사용률로 정렬합니다.


-M: 메모리 사용률로 정렬합니다.


-T: 실행 시간으로 정렬합니다.


그니까 예를들면 top -d 2 -n 5 를 입력하면 2초간격으로 업데이트되며 총 5번만큼만 업데이트하는것입니다.


# ps 명령어는 리눅스에서 현재 실행 중인 프로세스를 보여주는 명령어입니다. 프로세스 상태를 확인하고 모니터링하는 데 유용합니다.


다음과같은 정보를 확인할수있습니다.


PID: 프로세스 ID
, TTY: 프로세스가 연결된 터미널
, TIME: 프로세스가 사용한 총 CPU 시간
, CMD: 실행된 명령어


ps 명령어의 주요 옵션으로는


-e 또는 -A: 시스템의 모든 프로세스를 봅니다.


-u: 특정 사용자의 프로세스를 봅니다.


-f: 프로세스에 대한 자세한 정보를 봅니다.


aux: 모든 프로세스를 자세히 봅니다. 이 옵션은 대시를 붙이지않습니다. 그 이유로는 BSD 스타일의 옵션이기 때문입니다.


예를들어 ps -e -f 를 하면 모든 프로세스를 자세히 볼수있습니다. 그렇다면 ps aux랑 ps -e -f 의 차이점은 뭘까요?


ps aux는 CPU와 메모리 사용률(%CPU, %MEM), 가상 메모리(VSZ), 실제 메모리(RSS) 등을 포함한 정보를 출력합니다.


ps -ef는 프로세스의 부모 프로세스 ID(PPID), 프로세스 시작 시간(STIME), CPU 사용률(C) 등을 포함한 정보를 출력합니다.


jobs 명령어와 kill 명령어는 동시에 설명하겠습니다.


# jobs 명령어는 현재 셸 세션에서 실행 중이거나 일시 중지된 작업들의 상태를 보여주는 명령어입니다.


다음과같은 정보를 확인할수있습니다.


-l: 자세한 정보보기.


-p: 프로세스 ID만 보기.


-r: 현재 실행 중인 작업만 보기.


-s: 현재 일시 중지된 작업만 보기.


이와 관련해서 작업제어 관련 명령어로써는 


&: 명령어 끝에 &를 붙이면 해당 명령어를 백그라운드에서 실시합니다.


fg: 백그라운드에서 실행 중인 작업을 포그라운드로 가져옵니다.


bg: 일시 중지된 작업을 백그라운드에서 계속 실행합니다.


kill: 특정 작업이나 프로세스를 종료합니다. (프로세스 ID로도 종료가 가능합니다.)


예를 들어서 sleep 100 & 로써 백그라운드에서 sleep 100 명령어를 실행시키고 job -r 로써 현재 실행중인 sleep 100 명령어를 확인할수있고 kill %1 을 통해 sleep 100을 종료시킵니다. 이후 jobs 을 통해 종료된 sleep 100 을 확인 가능합니다.


kill 명렁어에 대해서 자세히 알아보겠습니다.


SIGTERM (15): 기본 신호. 프로세스에 종료를 요청합니다. 프로세스는 이를 수신하고 종료를 준비할 시간을 가질 수 있습니다.


SIGKILL (9): 강제 종료 신호. 프로세스를 즉시 종료합니다. 데이터 손실을 초래할 수 있으며, 프로세스가 종료를 준비할 시간을 갖지 않습니다.


SIGHUP (1): 연결이 끊겼음을 알리는 신호. 일반적으로 데몬 프로세스를 다시 시작하는 데 사용됩니다.


SIGINT (2): 인터럽트 신호. 일반적으로 키보드의 Ctrl+C에 의해 생성됩니다.


SIGSTOP (19): 프로세스를 일시 중지합니다. SIGCONT 신호를 보내야 다시 실행됩니다.


SIGCONT (18): 일시 중지된 프로세스를 계속 실행합니다.


등등 많이 존재합니다. 우선 예를 들어 PID가 1234인 프로세스가 있다고 가정하겠습니다. kill 1234 를 한다면 기본신호15에 맞게 종료가 됩니다. kill -9 1234를 한다면 강제 종료신호를 실행하게되는겁니다.
